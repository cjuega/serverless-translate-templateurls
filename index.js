"use strict";

const { readdir, unlink } = require("fs"),
    readdirAsync = require("util").promisify(readdir),
    unlinkAsync = require("util").promisify(unlink),
    path = require("path"),
    { exec } = require("child_process"),
    execAsync = require("util").promisify(exec),
    DEFAULT_IN_PATH = "cf-templates",
    DEFAULT_OUT_PATH = "resources",
    SQS_DEAD_LETTER_PREFIX = "DL",
    S3_PREFIX = "serverless-translate-templateurls";

/**
 *
 * @class ServerlessTranslateTemplateURLsPlugin
 */
class ServerlessTranslateTemplateURLsPlugin {
    /**
     * Creates an instance of ServerlessTranslateTemplateURLsPlugin.
     *
     * @param {*} serverless
     * @param {*} options
     * @memberof ServerlessTranslateTemplateURLsPlugin
     */
    constructor(serverless, options) {
        this.serverless = serverless;
        this.service = serverless.service;
        this.options = options;

        this.provider = this.serverless.getProvider("aws");

        this.commands = {
            translate: {
                lifecycleEvents: ["cfPackage"],
            },
        };

        this.hooks = {
            "before:package:cleanup": this.beforePackageCleanup.bind(this),
            "before:package:setupProviderConfiguration": this.beforePackageSetupProviderConfiguration.bind(
                this
            ),
            "before:remove:remove": this.beforeRemoveRemove.bind(this),
            "before:translate:cfPackage": this.beforePackageCleanup.bind(this),
            "before:offline:start": this.offlineStartInit.bind(this),
            "before:offline:start:init": this.offlineStartInit.bind(this),
            "translate:cfPackage": this.beforePackageSetupProviderConfiguration.bind(
                this
            ),
        };
    }

    /**
     *
     *
     * @memberof ServerlessTranslateTemplateURLsPlugin
     */
    async beforePackageCleanup() {
        this.serverless.cli.log(
            "serverless-translate-templateurls: cleaning up autogenerated files"
        );

        const files = await readdirAsync(this._outFolder);

        for (const f of files) {
            if (/^.+\.out\.(json|yml|yaml)$/.test(f)) {
                await unlinkAsync(path.join(this._outFolder, f));
            }
        }
    }

    /**
     *
     *
     * @memberof ServerlessTranslateTemplateURLsPlugin
     */
    async beforePackageSetupProviderConfiguration() {
        try {
            this.serverless.cli.log(
                "serverless-translate-templateurls: translating local templateURL paths"
            );

            await this._setServerlessDeploymentBucketName();

            const files = await readdirAsync(this._inFolder);

            for (const f of files) {
                await this._translate(path.join(this._inFolder, f));
            }
        } catch (err) {
            if (err.message.includes("' does not exist")) {
                this.serverless.cli.log(
                    "serverless-translate-templateurls: s3 bucket not found! local paths weren't translated!"
                );
                this.serverless.cli.log(
                    "serverless-translate-templateurls: ensure you set the s3Bucket custom variable or the stack is already created!"
                );
            } else {
                throw err;
            }
        }
    }

    /**
     *
     *
     * @memberof ServerlessTranslateTemplateURLsPlugin
     */
    async beforeRemoveRemove() {
        try {
            this.serverless.cli.log(
                "serverless-translate-templateurls: cleaning up S3 bucket"
            );

            await this._setServerlessDeploymentBucketName();

            const listResponse = await this.provider.request(
                "S3",
                "listObjectsV2",
                { Bucket: this.bucketName, Prefix: S3_PREFIX }
            );

            if (listResponse) {
                await this.provider.request("S3", "deleteObjects", {
                    Bucket: this.bucketName,
                    Delete: {
                        Objects: listResponse.Contents.map((c) => {
                            return { Key: c.Key };
                        }),
                    },
                });
            }
        } catch (err) {
            if (!err.message.includes("' does not exist")) {
                throw err;
            }
        }
    }

    async serverlessOfflineSqsSupport() {
        if (this.service) {
            const functionKeys = this.service.getAllFunctions();

            functionKeys.forEach((functionKey) => {
                const events =
                    this.service.getAllEventsInFunction(functionKey) || [];

                events.forEach(({ sqs }) => {
                    if (sqs && sqs.arn && sqs.arn["Fn::GetAtt"]) {
                        const attribute = sqs.arn["Fn::GetAtt"][1];

                        // rename GetAtt's second argument to 'Arn' as expected by serverless-offline-sqs.
                        // https://github.com/CoorpAcademy/serverless-plugins/blob/master/packages/serverless-offline-sqs/src/index.js#L207
                        if (
                            attribute.includes("Outputs.") &&
                            attribute.includes("Arn")
                        ) {
                            this.serverless.cli.log(
                                `serverless-translate-templateurls: renaming SQS event for function ${functionKey}`
                            );
                            sqs.arn["Fn::GetAtt"][1] = "Arn";
                        }
                    }
                });
            });

            if (this.service.resources && this.service.resources.Resources) {
                for (const r in this.service.resources.Resources) {
                    if (this.service.resources.Resources.hasOwnProperty(r)) {
                        const resource = this.service.resources.Resources[r];

                        if (
                            resource.Properties &&
                            resource.Properties.TemplateURL
                        ) {
                            if (resource.Properties.Parameters.QueueName) {
                                // assume SQS queue is created by the remote stack
                                this.serverless.cli.log(
                                    `serverless-translate-templateurls: mocking CloudFormation resource for SQS queue ${resource.Properties.Parameters.QueueName}`
                                );
                                // fake Type and QueueName property so serverless-offline-sqs detects (and manages) the queue
                                // https://github.com/CoorpAcademy/serverless-plugins/tree/master/packages/serverless-offline-sqs#functions
                                resource.Type = "AWS::SQS::Queue";
                                resource.Properties.QueueName =
                                    resource.Properties.Parameters.QueueName;
                            }


                            // checks if SQS have Dead Letter Queue and creates other
                            if(resource.Properties.Parameters.hasOwnProperty("MaxReceiveCount") 
                                && resource.Properties.Parameters.MaxReceiveCount > 0) {
                                const dlResourceName = SQS_DEAD_LETTER_PREFIX.concat(r),
                                    dlQueueName = `${SQS_DEAD_LETTER_PREFIX.toLowerCase()}-${resource.Properties.Parameters.QueueName}`;
                                this.serverless.cli.log(
                                    `serverless-translate-templateurls: mocking CloudFormation resource for SQS DL queue ${dlQueueName}`
                                );
                                // TODO: @cjuega I think about to way to do this
                                // 1ª way - clone the object exactly the same as the queue from which we want to generate a DeadLetter. 
                                // With this we would maintain the "semantics" of the new resource that we are creating
                                
                                // let dlQueue = Object.assign(resource);
                                // dlQueue.Type = "AWS::SQS::Queue";
                                // dlQueue.Properties.QueueName = dlQueueName;
                                // dlQueue.Properties.Parameters.QueueName = dlQueueName;

                                // 2º way - only copy the params needed to SQS offline to works
                                const dlQueue = Object.assign({},{
                                    Type: "AWS::SQS::Queue",
                                    QueueName: dlQueueName
                                });
                                
                                this.service.resources.Resources[dlResourceName] = dlQueue;
                            }
                        }
                    }
                }
            }
        }
    }

    async serverlessLocalS3Support() {
        if (
            this.service &&
            this.service.resources &&
            this.service.resources.Resources
        ) {
            for (const r in this.service.resources.Resources) {
                if (this.service.resources.Resources.hasOwnProperty(r)) {
                    const resource = this.service.resources.Resources[r];

                    if (
                        resource.Properties &&
                        resource.Properties.TemplateURL
                    ) {
                        if (resource.Properties.Parameters.BucketName) {
                            // assume S3 bucket is created by the remote stack
                            this.serverless.cli.log(
                                `serverless-translate-templateurls: mocking CloudFormation resource for S3 bucket ${resource.Properties.Parameters.BucketName}`
                            );
                            // fake BucketName property so serverless-s3-local detects (and manages) the bucket
                            // https://github.com/ar90n/serverless-s3-local/blob/master/index.js
                            resource.Properties.BucketName =
                                resource.Properties.Parameters.BucketName;
                        }
                    }
                }
            }
        }
    }

    async offlineStartInit() {
        this.serverless.cli.log(
            `serverless-translate-templateurls: fetching remote artifacts to mock resources offline.`
        );

        await this.serverlessOfflineSqsSupport();

        await this.serverlessLocalS3Support();
    }

    /**
     *
     *
     * @memberof ServerlessTranslateTemplateURLsPlugin
     */
    async _setServerlessDeploymentBucketName() {
        try {
            let bucket;

            if (
                this.service.custom &&
                this.service.custom["serverless-translate-templateurls"]
            ) {
                bucket = this.service.custom[
                    "serverless-translate-templateurls"
                ].s3Bucket;
            }

            this.bucketName =
                bucket ||
                (await this.provider.getServerlessDeploymentBucketName());
        } catch (err) {
            throw new this.serverless.classes.Error(
                `Could not locate deployment bucket. Error: ${err.message}`
            );
        }
    }

    /**
     *
     * @private
     * @readonly
     * @memberof ServerlessTranslateTemplateURLsPlugin
     */
    get _inFolder() {
        let ret = DEFAULT_IN_PATH;

        if (
            this.service.custom &&
            this.service.custom["serverless-translate-templateurls"]
        ) {
            ret =
                this.service.custom["serverless-translate-templateurls"]
                    .inFolder || ret;
        }

        return ret;
    }

    /**
     *
     * @private
     * @readonly
     * @memberof ServerlessTranslateTemplateURLsPlugin
     */
    get _outFolder() {
        let ret = DEFAULT_OUT_PATH;

        if (
            this.service.custom &&
            this.service.custom["serverless-translate-templateurls"]
        ) {
            ret =
                this.service.custom["serverless-translate-templateurls"]
                    .outFolder || ret;
        }

        return ret;
    }

    /**
     *
     * @private
     * @param {String} inpath
     * @memberof ServerlessTranslateTemplateURLsPlugin
     * @return {String}
     */
    _composeOutputPath(inpath) {
        return path.join(
            this._outFolder,
            `${path.basename(inpath, path.extname(inpath))}.out${path.extname(
                inpath
            )}`
        );
    }

    /**
     *
     *
     * @private
     * @param {String} inpath
     * @param {String} outpath
     * @memberof ServerlessTranslateTemplateURLsPlugin
     */
    async _translate(inpath, outpath) {
        if (!inpath) {
            return;
        }

        outpath = outpath || this._composeOutputPath(inpath);

        this.serverless.cli.log(
            `serverless-translate-templateurls: ${inpath} -> ${outpath}`
        );

        let args = "",
            profile = "";

        if (inpath.endsWith(".json")) {
            args += " --use-json";
        }

        if (this.serverless.service.provider.profile) {
            profile = this.serverless.service.provider.profile;
        }

        if (this.options.awsProfile) {
            profile = this.options.awsProfile;
        }

        if (profile) {
            args += ` --profile ${profile}`;
        }

        await execAsync(
            `aws cloudformation package --template-file ${inpath} --s3-bucket ${this.bucketName} --s3-prefix ${S3_PREFIX} ` +
                `--output-template-file ${outpath} ${args}`
        );
    }
}

module.exports = ServerlessTranslateTemplateURLsPlugin;
